/** @typedef {import('../attribute').Attribute} Attribute */
const { AttributeType } = require('../attribute');
const { LanguageMeta } = require("./language");

class CSharp extends LanguageMeta {
  getType(attribute, collections) {
    let type = "";
    switch (attribute.type) {
      case AttributeType.STRING:
      case AttributeType.EMAIL:
      case AttributeType.DATETIME:
        type = "string";
        if (attribute.format === AttributeType.ENUM) {
          type = LanguageMeta.toPascalCase(attribute.key);
        }
        break;
      case AttributeType.INTEGER:
        type = "int";
        break;
      case AttributeType.FLOAT:
        type = "double";
        break;
      case AttributeType.BOOLEAN:
        type = "bool";
        break;
      case AttributeType.RELATIONSHIP:
        const relatedCollection = collections.find(c => c.$id === attribute.relatedCollection);
        if (!relatedCollection) {
          throw new Error(`Related collection with ID '${attribute.relatedCollection}' not found.`);
        }
        type = LanguageMeta.toPascalCase(relatedCollection.name);
        if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany') {
          type = `List<${type}>`;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${attribute.type}`);
    }
    if (attribute.array) {
      type = `List<${type}>`;
    }
    if (!attribute.required) {
      type += "?";
    }
    return type;
  }

  getTemplate() {
    return `/// This file is auto-generated by the Appwrite CLI. 
/// You can regenerate it by running \`appwrite ${process.argv.slice(2).join(' ')}\`.

#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json.Serialization;

namespace Appwrite.Models
{
<% for (const attribute of collection.attributes) { -%>
<% if (attribute.format === 'enum') { -%>

public enum <%- toPascalCase(attribute.key) %> {
<% for (const [index, element] of Object.entries(attribute.elements) ) { -%>
    [JsonPropertyName("<%- element %>")]
    <%- toPascalCase(element) %><% if (index < attribute.elements.length - 1) { %>,<% } %>
<% } -%>
}
<% } -%>
<% } %>
public class <%= toPascalCase(collection.name) %>
{
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
    [JsonPropertyName("<%- attribute.key %>")]
    public <%- getType(attribute, collections) %> <%= toPascalCase(attribute.key) %> { get; private set; }

<% } -%>

    public <%= toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        <%- getType(attribute, collections) %> <%= toCamelCase(attribute.key) %><% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
    )
    {
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
        <%= toPascalCase(attribute.key) %> = <%= toCamelCase(attribute.key) %>;
<% } -%>
    }

    public static <%= toPascalCase(collection.name) %> From(Dictionary<string, object> map)
    {
        return new <%= toPascalCase(collection.name) %>(
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
            <%- toCamelCase(attribute.key) %>:<% 
            // ENUM
            if (attribute.format === 'enum') {
                if (attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => (<%- toPascalCase(attribute.key) %>)Enum.Parse(typeof(<%- toPascalCase(attribute.key) %>), e.ToString())).ToList()<%
                } else {
                    if (attribute.required) {
                        -%> (<%- toPascalCase(attribute.key) %>)Enum.Parse(typeof(<%- toPascalCase(attribute.key) %>), map["<%- attribute.key %>"].ToString())<%
                    } else {
                        -%> map["<%- attribute.key %>"] != null ? (<%- toPascalCase(attribute.key) %>)Enum.Parse(typeof(<%- toPascalCase(attribute.key) %>), map["<%- attribute.key %>"].ToString()) : null<%
                    }
                }
            // RELATIONSHIP
            } else if (attribute.type === 'relationship') {
                const relatedClass = toPascalCase(collections.find(c => c.$id === attribute.relatedCollection).name);
                if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany' || attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => Models.<%- relatedClass %>.From((Dictionary<string, object>)e)).ToList()<%
                } else {
                    if (attribute.required) {
                        -%> <%- relatedClass %>.From((Dictionary<string, object>)map["<%- attribute.key %>"])<%
                    } else {
                        -%> map["<%- attribute.key %>"] != null ? <%- relatedClass %>.From((Dictionary<string, object>)map["<%- attribute.key %>"]) : null<%
                    }
                }
            // INTEGER
            } else if (attribute.type === 'integer') {
                if (attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => Convert.ToInt32(e)).ToList()<%
                } else {
                    -%> map["<%- attribute.key %>"] != null ? Convert.ToInt32(map["<%- attribute.key %>"]) : (<%- attribute.required ? '0' : 'null' %>)<%
                }
            // FLOAT
            } else if (attribute.type === 'float') {
                if (attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => Convert.ToDouble(e)).ToList()<%
                } else {
                    -%> map["<%- attribute.key %>"] != null ? Convert.ToDouble(map["<%- attribute.key %>"]) : (<%- attribute.required ? '0.0' : 'null' %>)<%
                }
            // BOOLEAN
            } else if (attribute.type === 'boolean') {
                if (attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => Convert.ToBoolean(e)).ToList()<%
                } else {
                    -%> map["<%- attribute.key %>"] != null ? Convert.ToBoolean(map["<%- attribute.key %>"]) : (<%- attribute.required ? 'false' : 'null' %>)<%
                }
            // STRING, DATETIME, EMAIL
            } else if (attribute.type === 'string' || attribute.type === 'datetime' || attribute.type === 'email') {
                if (attribute.array) {
                    -%> (map["<%- attribute.key %>"] as IEnumerable<object>)<%- !attribute.required ? '?' : '' %>.Select(e => e.ToString()).ToList()<%
                } else {
                    if (attribute.required) {
                        -%> map["<%- attribute.key %>"].ToString()<%
                    } else {
                        -%> map["<%- attribute.key %>"]?.ToString()<%
                    }
                }
            // UNKNOWN
            } else {
                -%> null <%
            }
            -%><% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
        );
    }

    public Dictionary<string, object?> ToMap()
    {
        return new Dictionary<string, object?>
        {
<% for (const [index, attribute] of Object.entries(collection.attributes)) { -%>
            { "<%= attribute.key %>",<%
            // ENUM
            if (attribute.format === 'enum') {
                if (attribute.array) {
                    -%> <%= toPascalCase(attribute.key) %>?.Select(e => e.ToString()).ToList()<%
                } else {
                    -%> <%= toPascalCase(attribute.key) %>?.ToString()<%
                }
            // RELATIONSHIP
            } else if (attribute.type === 'relationship') {
                if ((attribute.relationType === 'oneToMany' && attribute.side === 'parent') || (attribute.relationType === 'manyToOne' && attribute.side === 'child') || attribute.relationType === 'manyToMany' || attribute.array) {
                    -%> <%= toPascalCase(attribute.key) %>?.Select(e => e.ToMap()).ToList()<%
                } else {
                    -%> <%= toPascalCase(attribute.key) %>?.ToMap()<%
                }
            // OTHER
            } else {
                -%> <%= toPascalCase(attribute.key) %><%
            }
            -%> }<% if (index < collection.attributes.length - 1) { %>,<% } %>
<% } -%>
        };
    }
}
}
`;
  }

  getFileName(collection) {
    return LanguageMeta.toPascalCase(collection.name) + ".cs";
  }
}

module.exports = { CSharp };
